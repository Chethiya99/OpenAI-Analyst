# -*- coding: utf-8 -*-
"""14.sql-agents-with-llama3-crewai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wgps6E0vbEnNKB9zh_2n6dirT97UMR9q
"""

# !pip -qqq install pip --progress-bar off
# !pip -qqq install langchain-core==0.2.9 --progress-bar off
# !pip -qqq install langchain-community==0.2.5 --progress-bar off
# !pip -qqq install 'crewai[tools]'==0.32.0 --progress-bar off
# !pip -qqq install langchain-groq==0.1.5 --progress-bar off
# !pip -qqq install langchain-experimental==0.0.61 --progress-bar off

# !pip install --upgrade pip  # Upgrade pip first
# !pip install langchain==0.2.17 langchain-core==0.2.43 langchain-community==0.2.19 crewai[tools]==0.32.0 langchain-groq==0.1.5 langchain-experimental==0.0.61

# !pip install --upgrade pip  # Upgrade pip first
# !pip install langchain langchain-core langchain-community crewai[tools] langchain-groq langchain-experimental

# Commented out IPython magic to ensure Python compatibility.
# %pip install langchain==0.1.4
#%pip install langchain-core==0.2.43
#%pip install langchain-community==0.2.19
# %pip install 'crewai[tools]==0.32.0'
#%pip install langchain-groq==0.1.5
#%pip install langchain-experimental==0.0.61

# !pip uninstall crewai crewai-tools
# !pip install 'crewai[tools]'

# Commented out IPython magic to ensure Python compatibility.
# %pip install langchain-groq==0.1.5

import json
import os
import sqlite3
from dataclasses import asdict, dataclass
from datetime import datetime, timezone
from pathlib import Path
from textwrap import dedent
from typing import Any, Dict, List, Tuple, Union

import pandas as pd
from crewai import Agent, Crew, Process, Task
from crewai_tools import tool
from google.colab import userdata
from langchain.schema import AgentFinish
from langchain.schema.output import LLMResult
from langchain_community.tools.sql_database.tool import (
    InfoSQLDatabaseTool,
    ListSQLDatabaseTool,
    QuerySQLCheckerTool,
    QuerySQLDataBaseTool,
)
from langchain_community.utilities.sql_database import SQLDatabase
from langchain_core.callbacks.base import BaseCallbackHandler
from langchain_core.prompts import ChatPromptTemplate
from langchain_groq import ChatGroq

os.environ["GROQ_API_KEY"] = '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'

!gdown 1Q7GnaGpXxmrI2S7mxKmeFFqj8dotsxAM

df = pd.read_csv("ds-salaries.csv")
df.head()

connection = sqlite3.connect("salaries.db")
df.to_sql(name="salaries", con=connection)

"""## LLM (Llama 3)"""

@dataclass
class Event:
    event: str
    timestamp: str
    text: str


def _current_time() -> str:
    return datetime.now(timezone.utc).isoformat()


class LLMCallbackHandler(BaseCallbackHandler):
    def __init__(self, log_path: Path):
        self.log_path = log_path

    def on_llm_start(
        self, serialized: Dict[str, Any], prompts: List[str], **kwargs: Any
    ) -> Any:
        """Run when LLM starts running."""
        assert len(prompts) == 1
        event = Event(event="llm_start", timestamp=_current_time(), text=prompts[0])
        with self.log_path.open("a", encoding="utf-8") as file:
            file.write(json.dumps(asdict(event)) + "\n")

    def on_llm_end(self, response: LLMResult, **kwargs: Any) -> Any:
        """Run when LLM ends running."""
        generation = response.generations[-1][-1].message.content
        event = Event(event="llm_end", timestamp=_current_time(), text=generation)
        with self.log_path.open("a", encoding="utf-8") as file:
            file.write(json.dumps(asdict(event)) + "\n")

llm = ChatGroq(
    temperature=0,
    model_name="llama3-70b-8192",
    callbacks=[LLMCallbackHandler(Path("prompts.jsonl"))],
)

human = "{text}"
prompt = ChatPromptTemplate.from_messages([("human", human)])

chain = prompt | llm
response = chain.invoke(
    {
        "text": "Which company has better models OpenAI or Anthropic? Respond with just the company name."
    }
)

print(response.content)

response.__dict__

"""## Tools"""

db = SQLDatabase.from_uri("sqlite:///salaries.db")



from crewai_tools import tool

@tool("list_tables")
def list_tables() -> str:
    """List the available tables in the database"""
    return ListSQLDatabaseTool(db=db).invoke("")

list_tables.run()

@tool("tables_schema")
def tables_schema(tables: str) -> str:
    """
    Input is a comma-separated list of tables, output is the schema and sample rows
    for those tables. Be sure that the tables actually exist by calling `list_tables` first!
    Example Input: table1, table2, table3
    """
    tool = InfoSQLDatabaseTool(db=db)
    return tool.invoke(tables)

print(tables_schema.run("salaries"))

@tool("execute_sql")
def execute_sql(sql_query: str) -> str:
    """Execute a SQL query against the database. Returns the result"""
    return QuerySQLDataBaseTool(db=db).invoke(sql_query)

execute_sql.run("SELECT * FROM salaries WHERE salary > 10000 LIMIT 5")

@tool("check_sql")
def check_sql(sql_query: str) -> str:
    """
    Use this tool to double check if your query is correct before executing it. Always use this
    tool before executing a query with `execute_sql`.
    """
    return QuerySQLCheckerTool(db=db, llm=llm).invoke({"query": sql_query})

check_sql.run("SELECT * WHERE salary > 10000 LIMIT 5 table = salaries")

"""## Agents"""

sql_dev = Agent(
    role="Senior Database Developer",
    goal="Construct and execute SQL queries based on a request",
    backstory=dedent(
        """
        You are an experienced database engineer who is master at creating efficient and complex SQL queries.
        You have a deep understanding of how different databases work and how to optimize queries.
        Use the `list_tables` to find available tables.
        Use the `tables_schema` to understand the metadata for the tables.
        Use the `execute_sql` to check your queries for correctness.
        Use the `check_sql` to execute queries against the database.
    """
    ),
    llm=llm,
    tools=[list_tables, tables_schema, execute_sql, check_sql],
    allow_delegation=False,
)

data_analyst = Agent(
    role="Senior Data Analyst",
    goal="You receive data from the database developer and analyze it",
    backstory=dedent(
        """
        You have deep experience with analyzing datasets using Python.
        Your work is always based on the provided data and is clear,
        easy-to-understand and to the point. You have attention
        to detail and always produce very detailed work (as long as you need).
    """
    ),
    llm=llm,
    allow_delegation=False,
)

report_writer = Agent(
    role="Senior Report Editor",
    goal="Write an executive summary type of report based on the work of the analyst",
    backstory=dedent(
        """
        Your writing still is well known for clear and effective communication.
        You always summarize long texts into bullet points that contain the most
        important details.
        """
    ),
    llm=llm,
    allow_delegation=False,
)

"""## Tasks"""

extract_data = Task(
    description="Extract data that is required for the query {query}.",
    expected_output="Database result for the query",
    agent=sql_dev,
)

analyze_data = Task(
    description="Analyze the data from the database and write an analysis for {query}.",
    expected_output="Detailed analysis text",
    agent=data_analyst,
    context=[extract_data],
)

write_report = Task(
    description=dedent(
        """
        Write an executive summary of the report from the analysis. The report
        must be less than 100 words.
    """
    ),
    expected_output="Markdown report",
    agent=report_writer,
    context=[analyze_data],
)

"""## Crew"""

crew = Crew(
    agents=[sql_dev, data_analyst, report_writer],
    tasks=[extract_data, analyze_data, write_report],
    process=Process.sequential,
    verbose=2,
    memory=False,
    output_log_file="crew.log",
)

inputs = {
    "query": "Effects on salary (in USD) based on company location, size and employee experience"
}

result = crew.kickoff(inputs=inputs)

print(result)

inputs = {
    "query": "How is the `Machine Learning Engineer` salary in USD is affected by remote positions"
}

result = crew.kickoff(inputs=inputs)

print(result)

"""## References

- [DS Salaries Dataset](https://huggingface.co/datasets/Einstellung/demo-salaries)
"""

import json
import os
from dataclasses import asdict, dataclass
from datetime import datetime, timezone
from pathlib import Path
from textwrap import dedent
from typing import Any, Dict, List

import pandas as pd
from crewai import Agent, Crew, Process, Task
from crewai_tools import tool
from langchain.schema.output import LLMResult
from langchain_community.tools.sql_database.tool import (
    InfoSQLDatabaseTool,
    ListSQLDatabaseTool,
    QuerySQLCheckerTool,
    QuerySQLDataBaseTool,
)
from langchain_community.utilities.sql_database import SQLDatabase
from langchain_core.callbacks.base import BaseCallbackHandler
from langchain_groq import ChatGroq

# Set up environment variable for API key (if needed)
os.environ["GROQ_API_KEY"] = "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"  # Replace with your actual API key if required

@dataclass
class Event:
    event: str
    timestamp: str
    text: str

def _current_time() -> str:
    return datetime.now(timezone.utc).isoformat()

class LLMCallbackHandler(BaseCallbackHandler):
    def __init__(self, log_path: Path):
        self.log_path = log_path

    def on_llm_start(self, serialized: Dict[str, Any], prompts: List[str], **kwargs: Any) -> Any:
        assert len(prompts) == 1
        event = Event(event="llm_start", timestamp=_current_time(), text=prompts[0])
        with self.log_path.open("a", encoding="utf-8") as file:
            file.write(json.dumps(asdict(event)) + "\n")

    def on_llm_end(self, response: LLMResult, **kwargs: Any) -> Any:
        generation = response.generations[-1][-1].message.content
        event = Event(event="llm_end", timestamp=_current_time(), text=generation)
        with self.log_path.open("a", encoding="utf-8") as file:
            file.write(json.dumps(asdict(event)) + "\n")

# Initialize the language model with callback handler
llm = ChatGroq(
    temperature=0,
    model_name="llama3-70b-8192",
    callbacks=[LLMCallbackHandler(Path("prompts.jsonl"))],
)

# Connect to the SQLite database (replace with your actual database URI)
db = SQLDatabase.from_uri("sqlite:///salaries.db")

# Define tools with proper registration
@tool("list_tables")
def list_tables() -> str:
    """List the available tables in the database."""
    print("Invoking list_tables tool...")  # Debugging output
    return ListSQLDatabaseTool(db=db).invoke("")

@tool("tables_schema")
def tables_schema(tables: str) -> str:
    """Output schema and sample rows for specified tables."""
    print(f"Invoking tables_schema tool for tables: {tables}")  # Debugging output
    tool = InfoSQLDatabaseTool(db=db)
    return tool.invoke(tables)

@tool("execute_sql")
def execute_sql(sql_query: str) -> str:
    """Execute a SQL query against the database. Returns the result."""
    print(f"Executing SQL query: {sql_query}")  # Debugging output
    return QuerySQLDataBaseTool(db=db).invoke(sql_query)

@tool("check_sql")
def check_sql(sql_query: str) -> str:
    """Check if a SQL query is correct before executing it."""
    print(f"Checking SQL query: {sql_query}")  # Debugging output
    return QuerySQLCheckerTool(db=db, llm=llm).invoke({"query": sql_query})

# Define Agents with access to tools and debugging output for initialization
sql_dev = Agent(
    role="Senior Database Developer",
    goal="Construct and execute SQL queries based on a request.",
    backstory=dedent("""
        You are an experienced database engineer who is master at creating efficient and complex SQL queries.
        You have a deep understanding of how different databases work and how to optimize queries.
        Use the `list_tables` to find available tables.
        Use the `tables_schema` to understand the metadata for the tables.
        Use the `execute_sql` to check your queries for correctness.
        Use the `check_sql` to execute queries against the database.
    """),
    llm=llm,
)

data_analyst = Agent(
    role="Senior Data Analyst",
    goal="You receive data from the database developer and analyze it.",
    backstory=dedent("""
        You have deep experience with analyzing datasets using Python.
        Your work is always based on the provided data and is clear,
        easy-to-understand and to the point. You have attention
        to detail and always produce very detailed work (as long as you need).
    """),
    llm=llm,
)

report_writer = Agent(
    role="Senior Report Editor",
    goal="Write an executive summary type of report based on the work of the analyst.",
    backstory=dedent("""
        Your writing still is well known for clear and effective communication.
        You always summarize long texts into bullet points that contain the most
        important details.
    """),
    llm=llm,
)

# Define Tasks with proper context and outputs passed between them
extract_data = Task(
    description="Extract data that is required for the query {query}.",
    expected_output="Database result for the query.",
    agent=sql_dev,
)

analyze_data = Task(
    description="Analyze the data from the database and write an analysis for {query}.",
    expected_output="Detailed analysis text.",
    agent=data_analyst,
    context=[extract_data],
)

write_report = Task(
    description=dedent("""
        Write an executive summary of the report from the analysis. The report
        must be less than 100 words.
    """),
    expected_output="Markdown report.",
    agent=report_writer,
    context=[analyze_data],
)

# Create Crew with agents and tasks defined above
crew = Crew(
    agents=[sql_dev, data_analyst, report_writer],
    tasks=[extract_data, analyze_data, write_report],
)

# Kick off process with initial inputs and error handling for debugging purposes
inputs = {
     "query": "Effects on salary (in USD) based on company location, size and employee experience."
}

try:
     result = crew.kickoff(inputs=inputs)
     print(result)  # Print or log result for debugging purposes.
except Exception as e:
     print(f"An error occurred during crew execution: {e}")

import json
import os
import warnings
from dataclasses import asdict, dataclass
from datetime import datetime, timezone
from pathlib import Path
from textwrap import dedent
from typing import Any, Dict, List

import pandas as pd
from crewai import Agent, Crew, Process, Task
from crewai_tools import Tool
from langchain.schema.output import LLMResult
from langchain_community.tools.sql_database.tool import (
    InfoSQLDatabaseTool,
    ListSQLDatabaseTool,
    QuerySQLCheckerTool,
    QuerySQLDataBaseTool,
)
from langchain_community.utilities.sql_database import SQLDatabase
from langchain_core.callbacks.base import BaseCallbackHandler
from langchain_core.runnables import RunnableConfig
from langchain_groq import ChatGroq

# Suppress warnings
warnings.filterwarnings("ignore", category=Warning)

# Set up environment variable for API key
os.environ["GROQ_API_KEY"] = "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"

@dataclass
class Event:
    event: str
    timestamp: str
    text: str

def _current_time() -> str:
    return datetime.now(timezone.utc).isoformat()

class LLMCallbackHandler(BaseCallbackHandler):
    def __init__(self, log_path: Path):
        self.log_path = log_path

    def on_llm_start(self, serialized: Dict[str, Any], prompts: List[str], **kwargs: Any) -> Any:
        assert len(prompts) == 1
        event = Event(event="llm_start", timestamp=_current_time(), text=prompts[0])
        with self.log_path.open("a", encoding="utf-8") as file:
            file.write(json.dumps(asdict(event)) + "\n")

    def on_llm_end(self, response: LLMResult, **kwargs: Any) -> Any:
        generation = response.generations[-1][-1].message.content
        event = Event(event="llm_end", timestamp=_current_time(), text=generation)
        with self.log_path.open("a", encoding="utf-8") as file:
            file.write(json.dumps(asdict(event)) + "\n")

# Initialize the language model with callback handler
llm = ChatGroq(
    temperature=0,
    model_name="llama3-70b-8192",
    callbacks=[LLMCallbackHandler(Path("prompts.jsonl"))],
)

# Connect to the SQLite database
db = SQLDatabase.from_uri("sqlite:///salaries.db")

class DatabaseTools:
    def __init__(self, db):
        self.db = db
        self.tools = self._create_tools()

    def _create_tools(self):
        return [
            Tool(
                name="list_tables",
                description="List the available tables in the database.",
                func=lambda: self.list_tables()
            ),
            Tool(
                name="tables_schema",
                description="Output schema and sample rows for specified tables.",
                func=lambda tables: self.tables_schema(tables)
            ),
            Tool(
                name="execute_sql",
                description="Execute a SQL query against the database.",
                func=lambda query: self.execute_sql(query)
            ),
            Tool(
                name="check_sql",
                description="Check if a SQL query is correct before executing it.",
                func=lambda query: self.check_sql(query)
            )
        ]

    def list_tables(self) -> str:
        """List the available tables in the database."""
        config = RunnableConfig()
        tool = ListSQLDatabaseTool(db=self.db)
        return tool.invoke("", config=config)

    def tables_schema(self, tables: str) -> str:
        """Output schema and sample rows for specified tables."""
        config = RunnableConfig()
        tool = InfoSQLDatabaseTool(db=self.db)
        return tool.invoke(tables, config=config)

    def execute_sql(self, sql_query: str) -> str:
        """Execute a SQL query against the database."""
        config = RunnableConfig()
        tool = QuerySQLDataBaseTool(db=self.db)
        return tool.invoke(sql_query, config=config)

    def check_sql(self, sql_query: str) -> str:
        """Check if a SQL query is correct before executing it."""
        config = RunnableConfig()
        tool = QuerySQLCheckerTool(db=self.db, llm=llm)
        return tool.invoke({"query": sql_query}, config=config)

# Initialize database tools
db_tools = DatabaseTools(db)

# Define Agents with proper tool access
sql_dev = Agent(
    role="Senior Database Developer",
    goal="Construct and execute SQL queries based on a request.",
    backstory=dedent("""
        You are an experienced database engineer who is master at creating efficient and complex SQL queries.
        You have a deep understanding of how different databases work and how to optimize queries.
        You know how to use the following tools:
        - list_tables: to see what tables are available
        - tables_schema: to understand table structure
        - check_sql: to verify query correctness
        - execute_sql: to run queries and get results
    """),
    llm=llm,
    tools=db_tools.tools
)

data_analyst = Agent(
    role="Senior Data Analyst",
    goal="You receive data from the database developer and analyze it.",
    backstory=dedent("""
        You have deep experience with analyzing datasets using Python.
        Your work is always based on the provided data and is clear,
        easy-to-understand and to the point. You have attention
        to detail and always produce very detailed work (as long as you need).
    """),
    llm=llm,
)

report_writer = Agent(
    role="Senior Report Editor",
    goal="Write an executive summary type of report based on the work of the analyst.",
    backstory=dedent("""
        Your writing still is well known for clear and effective communication.
        You always summarize long texts into bullet points that contain the most
        important details.
    """),
    llm=llm,
)

# Define Tasks with proper context and outputs
extract_data = Task(
    description="Extract data that is required for the query {query}. First list the tables, then check their schema, then create and execute appropriate SQL queries.",
    expected_output="Database result for the query.",
    agent=sql_dev,
)

analyze_data = Task(
    description="Analyze the data from the database and write an analysis for {query}.",
    expected_output="Detailed analysis text.",
    agent=data_analyst,
    context=[extract_data],
)

write_report = Task(
    description=dedent("""
        Write an executive summary of the report from the analysis. The report
        must be less than 100 words.
    """),
    expected_output="Markdown report.",
    agent=report_writer,
    context=[analyze_data],
)

# Create Crew with agents and tasks
crew = Crew(
    agents=[sql_dev, data_analyst, report_writer],
    tasks=[extract_data, analyze_data, write_report],
    process=Process.sequential  # Ensure tasks run in sequence
)

# Execute crew with error handling
inputs = {
    "query": "Effects on salary (in USD) based on company location, size and employee experience."
}

try:
    result = crew.kickoff(inputs=inputs)
    print("Crew execution completed successfully:")
    print(result)
except Exception as e:
    print(f"An error occurred during crew execution: {str(e)}")
    raise

!python --version

